#!/usr/bin/perl -w
#
# This file is part of Therion package
# Copyright (C) 1999 Martin Budaj
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

$basename = shift;
die "\nSpecify filename to process!\n\n" if not $basename;
$basename =~ s/\.mp$//;

# first, we import values from configuration file; 
# procedure ``units'' converts numerical values to TeX's big points

open(CONF, "Config") or die "\nCan't open Config file: $!\n\n";
while(<CONF>) {
    chomp;
    if (/^hsize:/i)	{$Hsize = units($')};
    if (/^vsize:/i)	{$Vsize = units($')};
    if (/^hoffset: */i) {if ($') {$Hoffset = units($')} else {$Hoffset = 0}}
    if (/^voffset: */i) {if ($') {$Voffset = units($')} else {$Voffset = 0}}
    if (/^output:\W*/i)	{$Outputfile = $'};
}
die "\nConfig not correct\n\n" unless $Hsize * $Vsize;

# all files with filename in format $basename.any_number are PostScript files
# produced by MetaPost; in file $basename.999 is stored pattern information;
# we don't have to read it

opendir DIR, ".";
@epsfiles = grep {/^$basename\.\d+$/o and !/^$basename\.999$/o} readdir DIR;
@extensions = grep {s/^$basename\.//o} @epsfiles;
@extensions = sort @extensions;
closedir DIR;

print STDOUT "\nProcessing EPS files...\n";

# next loop reads Bounding-Box information from each file
# and with simple transformations finds out, with which output sheets 
# this file interferes; this information is saved in hash MAPLISTS
# in form key=position_of_map_sheet, value=list_of_files

foreach $extension (@extensions) {
    open(IN, "$basename.$extension") or die;
  FIRSTPASS: while(<IN>) {
	chomp;
	if (/^%%BoundingBox: (-?\d+) (-?\d+) (-?\d+) (-?\d+)/) {
	    $llx = $1;
	    $lly = $2;
	    $urx = $3;
	    $ury = $4;
	    last FIRSTPASS;
    	}
    }
    $Llx = round(($llx - $Hoffset) / $Hsize);
    $Lly = round(($lly - $Voffset) / $Vsize);
    $Urx = round(($urx - $Hoffset) / $Hsize);
    $Ury = round(($ury - $Voffset) / $Vsize);
    for ($i = $Llx; $i <= $Urx; $i++) {
	for ($j = $Lly; $j <= $Ury; $j++) {
	    $MAPLISTS{"$i.$j"} .= " $extension";
	}
    }
}

# we need to know, whether MetaPost's internal variable ``prologues''
# was set to 1 (by reading first line of any of these files)

open(IN, "$basename.1");
$_=<IN>;
if (/EPSF/) {$Prologues=1} else {$Prologues=0};
close(IN);

# here begins main task; for each $Maplist we create new EPS-file
# and write some header comments

foreach $Maplist(keys %MAPLISTS) {
    open(OUT, ">$Outputfile.$Maplist.eps") or die 
			"\nCan't write output file: $!\n\n";
    if ($Prologues) {print OUT "%!PS-Adobe-3.0 EPSF-3.0\n"}
    else {print OUT "%!PS\n"};
    ($llx, $lly) = split /\./, $Maplist;
    $urx = $Hoffset + $Hsize * ($llx + 1); $llx *= $Hsize; $llx += $Hoffset;
    $ury = $Voffset + $Vsize * ($lly + 1); $lly *= $Vsize; $lly += $Voffset;
    print OUT "%%BoundingBox: $llx $lly $urx $ury\n";
    print OUT "%%Creator: MetaPost, mpp, therion\n";
    $Date = localtime(time);
    print OUT "%%CreationDate: $Date\n";
    print OUT "%%Pages: 1\n";
    ($tmp = $MAPLISTS{"$Maplist"}) =~ s/^ //;	# first character was space
    @UsedFiles = split / /, $tmp;		# files needed for this output sheet
    open (FONTS, ">fonts.tmp");			# we open some temporary files
    open (PATTERNS, ">patterns.tmp");
    open (MP, ">mpdata.tmp");
    
# next loop reads data from all $UsedFiles and writes to one of the temporary
# files; there are Patterns, Fonts and PostScript kinds of data
    
    foreach $extension (@UsedFiles) {
	open (IN, "$basename.$extension");
	$Inbody = $Inpattern = 0; 
	LINE: while(<IN>) {
	    if (/^%(\*Font|%DocumentFonts)/) {
		print FONTS;
	    }
	    if (/^%%Page: 1 1$/) {
		$Inbody = 1;
		next LINE;
	    }
	    next LINE if !$Inbody;
	    if (/^% Pattern/) {
		$Inpattern = 1;
	    }
	    last LINE if /^showpage$/;
	    if ($Inpattern) {print PATTERNS} else {print MP};
	    if (/^\/.+ exch def$/) {
		$Inpattern = 0;
	    }
	}
    }
    close(IN);
    close(FONTS);
    close(PATTERNS);
    close(MP); 
    open(Fonts, "fonts.tmp");	# processing of fonts temporary files
    if (-z Fonts) {}		# there are no fonts in this output page
    else {
        %FON = ();

# if $Prologues > 0, Type 1 fonts are used, we need only to collate
# names of all used fonts
	
        if ($Prologues) {
	    while(<Fonts>) {
		chomp;
	        /^%%DocumentFonts: /;
		@tmp = split / /, $';
		foreach $t(@tmp) {
		    $FON{"$t"} = 0;
		}
	    }
	    close(Fonts);
	    print OUT "%%DocumentFonts:";
	    foreach $tmp (sort keys %FON) {
		print OUT " $tmp";
	    }
	    print OUT "\n";
	    foreach $tmp (sort keys %FON) {
		print OUT " /$tmp /$tmp def\n";
	    }
	    print OUT "/fshow {exch findfont exch scalefont setfont show}bind def\n";
	}
	else {

# $Prologues = 0 indicates, that information about used characters for each
# font is available; we have to extract it and write to hash FON,
# where key=font-name size design-size, 
# 	value=(list 0..255, where used characters are set to 1)
	
	    while(<Fonts>) {
		chomp;
		/^%\*Font: (\w+ .+ .+) /;
		$FontDesc = $1;
		($FirstChar, $AllChars) = split /:/, $';
		$Char = hex($FirstChar);
		$Length = length ($AllChars) - 1;
		for $i(0..$Length) {
		    $d = hex(substr($AllChars, $i, 1));
		    if ($d >= 8) {$d=$d-8; $FON{"$FontDesc"}[$Char] = 1;}
		    if ($d >= 4) {$d=$d-4; $FON{"$FontDesc"}[$Char+1] = 1;}
		    if ($d >= 2) {$d=$d-2; $FON{"$FontDesc"}[$Char+2] = 1;}
		    if ($d >= 1) {$d=$d-1; $FON{"$FontDesc"}[$Char+3] = 1;}
		    $Char += 4;
		}
	    }
    	    foreach $FontDesc(keys %FON) {	# unused positions are set to 0
		for ($i=0; $i <= 255; $i++) {
		    $FON{"$FontDesc"}[$i] ||= 0;
		}
	    }
	    foreach $FontDesc(sort keys %FON) {	
		$Char = 0;
		while ($FON{"$FontDesc"}[$Char] != 1) {
		    $Char++;
		}
		$First = $Char;		# first used character in this font
		$Char = 255;
		while ($FON{"$FontDesc"}[$Char] != 1) {
		    $Char--;
		}
		$Last = $Char;		# last used character in this font
		
# we print hexadecimal font-usage information		
		
		$FirstChar = sprintf "%lx", $First;
		print OUT "%*Font: $FontDesc $FirstChar:";
		$b = 8;			# MetaPost's algorithm
		$d = 0;
		for $i($First..$Last) {
		    if ($b == 0) {
		        $tmp = sprintf "%lx", $d;
		        print OUT $tmp;
		        $d = 0;
		        $b = 8;
		    }
		    if ($FON{"$FontDesc"}[$i] == 1) {
			$d += $b;
		    }
		$b = int($b / 2);
	    }
	    $tmp = sprintf "%lx", $d;
	    print OUT "$tmp\n";
	    }
	}
	print OUT "%%EndProlog\n%%Page: 1 1\n";
    }
    close(Fonts);

# we copy the pattern definitions only once:    
    
    open(Patterns, "patterns.tmp");
    if (-z Patterns) {}
    else {
	%PAT = ();
	$CopyPat = 0;
	while(<Patterns>) {
	    chomp;
	    if (/^% Pattern:.+:/) {
		if (exists $PAT{"$'"}) {
		    $CopyPat = 0;
		}
		else {
		    $PAT{"$'"} = 1;
		    $CopyPat = 1;
		}
	    }
	    print OUT "$_\n" if $CopyPat;
	}
    }
    close(Patterns);

# Postscript data are simply moved to EPS file    
    
    open(MPin, "mpdata.tmp");
    while (<MPin>) {
	print OUT;
    }
    print OUT "showpage\n";
    print OUT "%%EOF\n";
    close(OUT);
    close(MPin);
    unlink("mpdata.tmp");
    unlink("fonts.tmp");
    unlink("patterns.tmp");
}

foreach $extension(@extensions) {
    unlink("$basename.$extension");
}
unlink("$basename.999");

# end of program, definitions of functions follow:

sub round ($) {			# round (0.1) = round (0.9) = 0
    my $tmp = shift;		# round (-.1) = round (-.9) = -1
    if ($tmp >= 0) {
	return int($tmp);
    }
    else {
	return int($tmp) - 1;
    }
}

# following function converts some dimensions to PostScript points

sub units ($) {
    my $tmp = shift;
    my ($Num, $Unit);
    $tmp =~ /[a-z]+/;
    $Num = $`; $Unit = $&;
    $Num =~ s/ //g; $Unit =~ s/ //g;
    if ($Unit eq "bp") {return $Num}			# PostScript points
    elsif ($Unit eq "pt") {return ($Num * 72 / 72.27)}	# points
    elsif ($Unit eq "pc") {return ($Num * 864 / 72.27)}	# picas
    elsif ($Unit eq "in") {return ($Num * 72)}		# inches
    elsif ($Unit eq "cm") {return ($Num * 72 / 2.54)}	
    elsif ($Unit eq "mm") {return ($Num * 72 / 25.4)}
    elsif ($Unit eq "dd") {return ($Num * 1.0660111)}	# Didot points
    elsif ($Unit eq "cc") {return ($Num * 12.792133)}	# cicero = 12 dd
    else {die "\nUnknown length unit in Config file!\n\n"}
}