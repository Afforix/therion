#!/usr/bin/perl
#
#
# Init script

print STDOUT "This is therion importer.\n";
die "Usage: import file1 [file2 ... fileN]\n" unless (@ARGV);
print STDOUT "\n";
print "Loading packages: ";

%thCOMMANDS = ( 'survey' => '');

$thEXPORTFNAME = 'th__data.exp';

open thEXPORTFILE, '>' . $thEXPORTFNAME;
close thEXPORTFILE;

# end of init script




package default;

sub polyfix_PXYZ_MMM {
    return split /\s+/, shift;
    };

sub polydata_FTAIL_GGM {
    my ($f, $t, $a, $i, $l) = split /\s+/, shift;
    ($a, $i) *= 0.9;
    return ($f, $t, $l, $a, $i);
    };

sub polydata_STIAVN {
    my ($f, $t, $a, $i, $l) = split /\s+/, shift;
    $a += 180.0;
    return ($f, $t, $l, $a, $i);
    };

sub polydata_STIAVN2 {
    my ($f, $t, $a, $i, $l) = split /\s+/, shift;
    return ($f, $t, $l, $a, $i);
    };

package polygon;

print STDOUT "polygon, ";

$export_file_name = 'th__data.svx';

$main::thCOMMANDS{'polygon'} = 'polygon::export_survex';

open thPOLYGONFILE, '>' . $export_file_name;
print thPOLYGONFILE ";Therion survex export\n";
close thPOLYGONFILE;

sub svx_export_norm_point {
    my $point = @_[0];
    $point = main::export_norm_point($point);
    $point =~ s/\@/\./;
    return $point;
    };

sub export_svx_shot {
    my $data = shift;
    my ($f, $t, $l, $a, $i) = &{$polygon_data_trans_sub} ($data);
    $f = svx_export_norm_point($f);
    $t = svx_export_norm_point($t);
    print thPOLYGONFILE "$f\t$t\t$l\t$a\t$i\n";
    };

sub export_svx_fix {
    my ($point, $XC, $YC, $ZC) = &{$polygon_fix_trans_sub}(@_[0]);
    $point = svx_export_norm_point($point);
    print thPOLYGONFILE "*fix $point $XC $YC $ZC\n";
    };

sub export_svx_equate {
    my @points = split /\s+/, @_[0];
    print thPOLYGONFILE '*equate';
    foreach my $point (@points) {
            $point = svx_export_norm_point($point);
            print thPOLYGONFILE " $point";
            };
    print thPOLYGONFILE "\n";
    };

sub export_survex {
       
    ($polygon_data_trans_sub, $polygon_fix_trans_sub) =
    ('default::polydata_FTAIL_GGM','default::polyfix_PXYZ_MMM');

    open thPOLYGONFILE, '>>' . $export_file_name;
    my $numlines = @_;
    my $linenum = 0;

    LINE:
    while ($linenum < $numlines) {
          my $line = @_[$linenum];

          if ($line =~ /^\s*\\(\w+)\s*(.*)$/) {

             my ($command, $parameter) = ($1, $2);
             if ($command =~ 'equate') {export_svx_equate($parameter);
                next LINE;};
             if ($command =~ 'fix') {export_svx_fix($parameter);
                next LINE;};
             if ($command =~ 'chdir') {&main::update_csurveydir($parameter);
                next LINE;};
             if ($command =~ 'transform') {&main::define_transform($parameter);
                 next LINE;
		     };
             if ($command =~ 'polytrans') {$polygon_data_trans_sub = $parameter;
                next LINE;};
             if ($command =~ 'fixtrans') {$polygon_fix_trans_sub = $parameter;
                next LINE;};
             next LINE;
             };

          if ($line =~ /^\s*$/) {next LINE};
          export_svx_shot ($line);

          } continue {
          $linenum++;
          };

    close thPOLYGONFILE;
    }

# end of polygon package



package map;

print STDOUT "map, ";

$main::thCOMMANDS{'map'} = ' map::export_map';

sub get_point_coord {
    unless (shift =~ /^([0-9\-\.]+[pm])?([0-9\-\.]+)?\/?([0-9\-\.dg]*)\/?([0-9\-\.dg]*)(".*")?$/) {return};
    my ($dv,$l,$a,$i,$name) = ($1, $2, $3, $4, $5);
    if ($a eq '') {$a = '-'};
    if ($i eq '') {$i = '-'};
    if ($dv eq '') {$dv = '-'};
    if ($l eq '') {$l = '-'};
    if ($name !~ /".*"/) {$name = '""';};
    return (join ';', ($mapshot_f, $mapshot_t, $dv, $l, $a, $i, $name));
};

sub get_line_params {
    my @cmds = split /\s+/, shift;

    #backup shot points
    my ($mshot_bf, $mshot_bt) = ($mapshot_f, $mapshot_t);

    #get line name
    my $line_name = '""';
    if ($cmds[0] =~ /^(\w+):$/) {
       $line_name = '"' . $1 . '"';
       shift @cmds;
    };

    my $line_cycle = '0';

    my $cmds_count = @cmds;
    my $cmds_cur = 0;
    my $cpt = -1;
    my @pts = (['','-','-','..']);

    COMMAND:
    while ($cmds_cur < $cmds_count) {
          my $ccom = $cmds[$cmds_cur];

          # set shot points
          if ($ccom =~ /\[(.+)\]/) {
             $mapshot_f = main::export_norm_point($1);
             $mapshot_t = $mshot_bt;
             $ccc = $cmds_cur + 1;
             while ($ccc < $cmds_count) {
                   if ($cmds[$ccc] =~ /\[(.+)\]/) {
                      $mapshot_t = main::export_norm_point($1);
                      last;
                   };
                   $ccc++;
             };
          }
          elsif ($ccom eq 'cycle') {$line_cycle = '1'}
          elsif (($ccom =~ /^([\.\-]{2,3})$/) && ($cpt>=0)) {$pts[$cpt][3] = $1}
          elsif ($ccom =~ /^(\w+)>>$/) {$pts[$cpt+1][1] = $1}
          elsif (($ccom =~ /^>>(\w+)$/) && ($cpt>=0)) {$pts[$cpt][2] = $1}
          else {
               my $ccor = get_point_coord $ccom;
               if ($ccor) {
                  $cpt++;
                  $pts[$cpt][0] = $ccor;
                  $pts[$cpt+1] = ['','-','-','..'];
               };
          };
    } continue {
    $cmds_cur++;
    };

    #restore shot points
    ($mapshot_f, $mapshot_t) = ($mshot_bf, $mshot_bt);

    #create output string

    my $line_points = '';
    for my $ccc (0 .. $cpt) {
        $line_points .= ' ' . join(';', @{$pts[$ccc]});
        };

    return join(' ',($line_name,$line_cycle,$line_points));

};

sub export_stone {
    my @stones = split /;\s*/ ,shift;
    foreach my $stone (@stones) {
            my @params = split /\s+/, $stone;
            my $crd = get_point_coord shift @params;
            if ($crd) {
               $crd .= " " . join " ", @params;
               print thEXPORTFILE "*stone $crd\n";
            };
    };
};

sub export_sand {
    my @sands = split /;\s+/ ,shift;
    foreach my $sand (@sands) {
            my @params = split /\s+/, $sand;
            my $crd = get_point_coord shift @params;
            if ($crd) {
               $crd .= " " . join " ", @params;
               print thEXPORTFILE "*sand $crd\n";
            };
    };
};


sub set_shot {
    my @points = split /\s+/, shift;
    $mapshot_f = main::export_norm_point (shift @points);
    $mapshot_t = main::export_norm_point (shift @points);
};


sub export_wall {
    my @walls = split /;\s+/, shift;
    foreach my $wall (@walls) {
            my $wallpar = get_line_params $wall;
            print thEXPORTFILE "*wall $wallpar\n";
    };
};

sub export_pit {
    my @pits = split /;\s+/, shift;
    foreach my $pit (@pits) {
            my $pitpar = get_line_params $pit;
            print thEXPORTFILE "*pit $pitpar\n";
    };
};

sub export_border {
    my @borders = split /;\s+/, shift;
    foreach my $border (@borders) {
            my $borderpar = get_line_params $border;
            print thEXPORTFILE "*border $borderpar\n";
    };
};

sub export_lake {
    my @paths = split /\s+/, shift;
    my $paths = join ' ', @paths;
    print thEXPORTFILE "*lake $paths\n";
};

sub export_label {
    my @params = split /\s+\:\s+/, shift;
    my @posp = split /\s+/, shift @params;
    my $text = join ' : ', @params;
    my $crd = get_point_coord shift @posp;
    unless ($posp[0]) {$posp[0] = '0'};
    unless ($posp[1]) {$posp[1] = 'rt'};
    $pars = join ' ', ($crd, $posp[0], $posp[1]);
    print thEXPORTFILE "*label $pars $text\n";
};

sub export_specialpoint {
    my @params = split /\s+/, shift;
    my $point = shift @params;
    my $text = join ' ', @params;
    my $crd = get_point_coord $point;
    print thEXPORTFILE "*specialpoint $crd $text\n";
};

sub export_title {
    my @params = split /\s+\:\s+/, shift;
    my $path = shift @params;
    my $text = join ' : ', @params;
    my $ppth = get_line_params $path;
    print thEXPORTFILE "*title $ppth : $text\n";
};

sub export_specialpath {
    my @params = split /\s+\:\s+/, shift;
    my $path = shift @params;
    my $text = join ' : ', @params;
    my $ppth = get_line_params $path;
    print thEXPORTFILE "*specialpath $ppth : $text\n";
};

sub export_special {
    my $text = shift;
    print thEXPORTFILE "*special $text\n";
};

sub export_polygon {
    my @pts = split /\s+/, shift;
    my $lpt = pop @pts;
    my $pth = '';
    foreach $ppp (@pts) {$pth .= "[$ppp] 0p0 --- "};
    $pth .= "100p0 [$lpt]";
    $pth = get_line_params $pth;
    print thEXPORTFILE "*polygon $pth\n";
};

sub export_map {

    open thEXPORTFILE, '>>' . $main::thEXPORTFNAME;
    print thEXPORTFILE "map::\n";

    my $numlines = @_;
    my $linenum = 0;

    LINE:
    while ($linenum < $numlines) {
          my $line = @_[$linenum];
          if ($line =~ /^\s*\\(\w+)\s*(.*)$/) {
             my ($command, $parameter) = ($1, $2);
             if ($command eq 'stone') {export_stone $parameter}
             elsif ($command eq 'sand') {export_sand $parameter}
             elsif ($command eq 'shot') {set_shot $parameter}
             elsif ($command eq 'break') {print thEXPORTFILE "map::\n"}
             elsif ($command eq 'wall') {export_wall $parameter}
             elsif ($command eq 'pit') {export_pit $parameter}
             elsif ($command eq 'border') {export_border $parameter}
             elsif ($command eq 'lake') {export_lake $parameter}
             elsif ($command eq 'label') {export_label $parameter}
             elsif ($command eq 'polygon') {export_polygon $parameter}
             elsif ($command eq 'title') {export_title $parameter}
             elsif ($command eq 'specialpoint') {export_specialpoint $parameter}
             elsif ($command eq 'specialpath') {export_specialpath $parameter}
             elsif ($command eq 'special') {export_special $parameter}
             };
          } continue {
          $linenum++;
          };

    close thEXPORTFILE;
    }

# end of map package



package main;

# This package does following:
# 1. Traverses entire file structure
# 2. Fills hash thSURVEYS and gives ID number to each survey
# 3. Process all the data according to the thCOMMANDS hash

print "main.\n\n";

# Traverse entire file structure and create a summary file named th__data.th

print STDOUT "Traversing input file structure...";

open 'thDATAFILE', '>th__data.th';

foreach $file (@ARGV) {
        appendfile ($file, 'fh000');
        }

sub appendfile {                            # appends file to summary file

    local($filename, $input) = @_;
    $filename =~ /(.*\/)/;                  # gets file's directory
    local $currentdir = $1;
    $input++;

    unless (open $input, $filename) {
           print STDERR "Couldn't open $filename: $!\n";
           return;
           };

    # chdir for later file attachement
    print thDATAFILE "\\chdir $currentdir\n";    

    while (<$input>) {

          if (/^\s*\\include (.*)/) {       # search the include file
             appendfile ($currentdir . $1, $input);
             print thDATAFILE "\\chdir $currentdir\n";
             }

             else {                         # write line to summary file
                  s/(\\\s*$)//;             # join lines ended with '\'
                  print thDATAFILE;
                  };
             };
    };                                      # end of appendfile

close thDATAFILE;

print STDOUT "done.\n";



# Scan the data file for surveys and give them ID

print STDOUT "Scaning survey structure...";

open thDATAFILE, 'th__data.th';

$default_name = 'survey0000';
$current_survey = '';
$survey_id=0;

while (<thDATAFILE>) {
      if (/^\s*\\survey\s*(\w*)/) {   # \survey found
         $survey_name = $1;
         unless (length($survey_name)) {$survey_name = ++$default_name;};
         if (length($current_survey)) {$survey_name .= '.'};
         $current_survey = $survey_name . $current_survey;
         unless (defined $thSURVEYS{$current_survey}) {
                $thSURVEYS{$current_survey} = ++$survey_id;
                };
         };
      if (/^\s*\\endsurvey/) {                 # \endsurvey found
         $current_survey =~ /\.(.+)$/;
         $current_survey = $1;
         };
      };

close thDATAFILE;

print STDOUT "done.\n";



# process all data

print STDOUT "Processing data...";

open thDATAFILE, 'th__data.th';

$default_name = 'survey0000';
$current_survey = '';
@current_data = ();
$current_sub = '';
$current_prefix = '';

sub process_current_data {
    if ((length($current_sub) > 0) && (@current_data > 0)
       && ($thCSURVEYID > 0)) {
       eval "$current_sub(\@current_data)";
       };
    $current_sub = '';
    $current_prefix = '';
    @current_data = ();
    };

LINE:
while (<thDATAFILE>) {

      next LINE if (/^\s*#/);

      if (/^\s*\\survey\s*(\w*)/) {   # \survey found
         process_current_data;
         $survey_name = $1;
         unless (length($survey_name)) {$survey_name = ++$default_name;};
         if (length($current_survey)) {$survey_name .= '.'};
         $current_survey = $survey_name . $current_survey;
         $thCSURVEYNAME = $current_survey;
         $thCSURVEYID = $thSURVEYS{$thCSURVEYNAME};
         next LINE;
         };

      if (/^\s*\\endsurvey/) {                 # \endsurvey found
         process_current_data;
         $current_survey =~ /\.(.+)$/;
         $current_survey = $1;
         $thCSURVEYNAME = $current_survey;
         $thCSURVEYID = $thSURVEYS{$thCSURVEYNAME};
         next LINE;
         };

      if (/^\s*\\chdir\s*(.*)$/) {
         $thCSURVEYDIR = $1;
         next LINE;
         }

      $read_line = $_;
      $read_line =~ /^\s*\\(\w+)/;
      $read_type = $1;

      # if we're in definition block of some object.
      if (length($current_prefix) > 0) {
         if ($read_type eq $current_prefix) {
            push @current_data, $read_line;
            process_current_data;
            next LINE;
            }
         }

      elsif (defined $thCOMMANDS{$read_type}) {
         process_current_data;
         $current_sub = $thCOMMANDS{$read_type};
         $current_prefix = 'end' . $read_type;
         };

      push @current_data, $read_line;
      };

close thDATAFILE;

print STDOUT "done.\n";



# This sub returns a normalized format of point's name

sub export_norm_point {
    my $outpoint = shift;

    if ($outpoint =~ /^(\S+)@(\S*)$/) {

       my $pname = $1;
       my $sname = $2;

       if (length($thCSURVEYNAME) > 0) {
          $sname .= '.' . $thCSURVEYNAME;
          };

       if (defined($thSURVEYS{$sname})) {
          $outpoint = $pname . '@' . $thSURVEYS{$sname};
          } else { $outpoint =~ s/\@/\./; $outpoint .= '@' . $thCSURVEYID};

       return $outpoint;
       }

    else {
         $outpoint .= '@' . $thCSURVEYID;
         return $outpoint;
         };
    };

sub define_transform {
    package defined;
    do $main::thCSURVEYDIR . @_[0];
    package main;
    };

sub update_csurveydir {
    $thCSURVEYDIR = @_[0];
    };


# end of main

__END__


Global symbols used in this script:

thDATAFILE - file handle for summary file
%thCOMMANDS - hash of known global commands (definition indicators)
%thSURVEYS  - hash of all surveys with their ID
$thCSURVEYNAME  - name of current survey
$thCSURVEYID - id of current survey
$thCSURVEYDIR - directory of current survey

